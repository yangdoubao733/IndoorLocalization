# 多径传播模式使用指南

## 概述

多径传播追踪模式是对高精度射线追踪的进一步增强，能够模拟真实的电磁传播环境中的多径效应。

### 与高精度模式的区别

| 特性 | 高精度反射模式 | 多径传播模式 |
|------|----------------|--------------|
| 追踪方式 | 单一最优路径 | 所有可能路径 |
| 射线发射 | 定向发射（TX→RX方向） | 全方向发射（360条射线） |
| 反射追踪 | 追踪到第一次到达 | 追踪所有反射路径 |
| 功率计算 | 单条路径损耗 | 多条路径功率叠加 |
| 真实性 | 较高 | 极高（完全模拟多径） |
| 计算时间 | 中等（10-30秒） | 较慢（1-5分钟） |
| 适用场景 | 一般室内定位 | 高精度定位、信道建模 |

## 工作原理

### 1. 射线发射

多径模式从发射机位置向**所有方向**均匀发射射线，使用**Fibonacci球面采样算法**确保均匀分布：

```
发射机 → 360条射线（可配置） → 球面均匀分布
```

### 2. 路径追踪

每条射线独立追踪，记录所有能到达接收点的路径：

```
射线1 → 直射路径到达RX ✓
射线2 → 反射1次到达RX ✓
射线3 → 反射2次到达RX ✓
射线4 → 反射3次到达RX ✓
射线5 → 能量耗尽/未到达 ✗
...
```

### 3. 功率叠加

最终接收功率 = 所有有效路径的**线性功率之和**（非dB相加）：

```python
# 错误做法（dB直接相加）
total_power_dbm = path1_dbm + path2_dbm + path3_dbm  # ❌

# 正确做法（转换为线性功率后相加）
power1_linear = 10^(path1_dbm / 10)
power2_linear = 10^(path2_dbm / 10)
power3_linear = 10^(path3_dbm / 10)

total_power_linear = power1_linear + power2_linear + power3_linear
total_power_dbm = 10 * log10(total_power_linear)  # ✓
```

## 配置参数

### 基础配置

```python
config = {
    # 启用多径追踪
    'multipath_enabled': True,

    # 发射射线数量（越多越精确，但越慢）
    'num_rays': 360,  # 推荐：180-720

    # 接收点容差距离（米）
    'rx_tolerance': 0.3,  # 推荐：0.2-0.5

    # 功率阈值（低于此值的路径被忽略）
    'power_threshold_dbm': -100.0,  # 推荐：-100 到 -80

    # 最大反射次数
    'max_reflections': 3,  # 推荐：2-4
}
```

### 参数说明

#### num_rays（射线数量）

- **作用**：控制发射的射线密度
- **影响**：
  - 数量越多 → 能发现更多路径 → 结果越精确
  - 数量越少 → 计算越快 → 可能遗漏某些路径

| 射线数 | 角度间隔 | 计算时间（10×10m） | 路径发现率 | 推荐场景 |
|--------|----------|-------------------|-----------|----------|
| 180    | ~2.8°    | ~30秒             | 85%       | 快速测试 |
| 360    | ~2.0°    | ~1分钟            | 95%       | 标准使用 |
| 720    | ~1.4°    | ~2分钟            | 99%       | 高精度   |
| 1440   | ~1.0°    | ~5分钟            | 99.9%     | 科研级   |

#### rx_tolerance（接收容差）

- **作用**：射线与接收点的距离阈值
- **影响**：
  - 太小（<0.2m）→ 路径太少 → 信号弱
  - 太大（>0.5m）→ 路径太多 → 不真实

**推荐值**：0.3米（适合大多数场景）

#### power_threshold_dbm（功率阈值）

- **作用**：忽略弱信号路径
- **影响**：
  - 阈值高（-80dBm）→ 只保留强路径 → 快速但不完整
  - 阈值低（-120dBm）→ 保留所有路径 → 慢但完整

**推荐值**：
- 快速模式：-90 dBm
- 标准模式：-100 dBm
- 完整模式：-110 dBm

## 使用方法

### 方法1：从配置启用

```python
from src.simulation import create_ray_tracer
from src.models import load_model

# 加载模型
model = load_model('data/models/office.dae')

# 配置多径追踪
config = {
    'tx_frequency': 2.4e9,
    'tx_power': 20.0,

    # 启用多径模式
    'multipath_enabled': True,
    'num_rays': 360,
    'rx_tolerance': 0.3,
    'power_threshold_dbm': -100.0,

    # 高精度模式参数
    'high_precision_mode': True,  # 同时需要启用
    'max_reflections': 3,
    'default_material': 'concrete',
}

# 创建多径射线追踪器
tracer = create_ray_tracer(model, config)

# 模拟两点间信号（自动使用多径模式）
tx_pos = np.array([2.0, 2.0, 2.5])
rx_pos = np.array([8.0, 8.0, 1.5])

rssi = tracer.simulate_signal(tx_pos, rx_pos)
print(f"接收信号强度: {rssi:.2f} dBm")
```

### 方法2：直接创建MultipathRayTracer

```python
from src.simulation.multipath_tracing import MultipathRayTracer

# 直接创建多径追踪器
tracer = MultipathRayTracer(model, config)

# 追踪所有路径
tx_pos = np.array([2.0, 2.0, 2.5])
rx_pos = np.array([8.0, 8.0, 1.5])

paths = tracer.trace_all_paths_multipath(tx_pos, rx_pos)

print(f"发现 {len(paths)} 条有效路径:")
for i, path in enumerate(paths[:5]):  # 显示前5条
    print(f"  路径{i+1}: {path.num_bounces}次反射, "
          f"距离{path.total_distance:.2f}m, "
          f"损耗{path.total_loss:.2f}dB")

# 计算总功率
total_power = tracer.combine_multipath_power(paths)
print(f"多径叠加后总功率: {total_power:.2f} dBm")
```

### 方法3：与指纹库结合

```python
from src.fingerprint import FingerprintBuilder

# 创建多径追踪器
config['multipath_enabled'] = True
tracer = create_ray_tracer(model, config)

# 构建指纹库（自动使用多径模式）
builder = FingerprintBuilder(tracer)

# 定义AP位置
ap_positions = [
    np.array([1.0, 1.0, 2.5]),
    np.array([9.0, 1.0, 2.5]),
    np.array([1.0, 9.0, 2.5]),
    np.array([9.0, 9.0, 2.5]),
]

# 构建（会自动使用多径追踪）
builder.build_grid_fingerprints(
    ap_positions=ap_positions,
    x_range=(0, 10),
    y_range=(0, 10),
    z=1.5,
    grid_spacing=1.0
)

builder.save('data/fingerprints/multipath_fingerprint.pkl')
```

## 性能优化建议

### 1. 参数调优

**快速预览模式**（适合测试）：
```python
config = {
    'multipath_enabled': True,
    'num_rays': 180,
    'rx_tolerance': 0.4,
    'power_threshold_dbm': -90.0,
    'max_reflections': 2,
}
```

**标准模式**（适合大多数应用）：
```python
config = {
    'multipath_enabled': True,
    'num_rays': 360,
    'rx_tolerance': 0.3,
    'power_threshold_dbm': -100.0,
    'max_reflections': 3,
}
```

**高精度模式**（适合科研/高精度定位）：
```python
config = {
    'multipath_enabled': True,
    'num_rays': 720,
    'rx_tolerance': 0.2,
    'power_threshold_dbm': -110.0,
    'max_reflections': 4,
}
```

### 2. 计算时间估算

| 场景 | 射线数 | 反射次数 | 单点计算时间 | 指纹库（100点） |
|------|--------|----------|-------------|----------------|
| 小房间（5×5m） | 360 | 2 | ~30秒 | ~50分钟 |
| 中房间（10×10m） | 360 | 3 | ~1分钟 | ~1.5小时 |
| 大房间（20×20m） | 360 | 3 | ~2分钟 | ~3小时 |

**优化建议**：
- 先用简化模式快速构建，确认AP位置合理
- 再用多径模式重新构建关键区域
- 考虑使用更大的网格间距（2米而非1米）

### 3. 内存优化

多径模式会存储所有路径信息，可能占用大量内存。如果内存不足：

```python
# 方法1：提高功率阈值（减少路径数量）
config['power_threshold_dbm'] = -90.0  # 从-100提高到-90

# 方法2：减少射线数
config['num_rays'] = 180  # 从360减少到180

# 方法3：减少最大反射次数
config['max_reflections'] = 2  # 从3减少到2
```

## 典型应用场景

### 1. 信道建模

分析室内环境的多径特性：

```python
paths = tracer.trace_all_paths_multipath(tx_pos, rx_pos)

# 统计多径特性
direct_paths = [p for p in paths if p.num_bounces == 0]
single_bounce = [p for p in paths if p.num_bounces == 1]
multi_bounce = [p for p in paths if p.num_bounces >= 2]

print(f"直射路径: {len(direct_paths)}")
print(f"一次反射: {len(single_bounce)}")
print(f"多次反射: {len(multi_bounce)}")

# 时延扩展分析
delays = [(p.total_distance / 3e8) * 1e9 for p in paths]  # 纳秒
print(f"最大时延扩展: {max(delays) - min(delays):.2f} ns")
```

### 2. NLOS环境定位

在严重非视距（NLOS）环境中，多径模式能显著提升定位精度：

```python
# 地下室、密集办公室等NLOS严重的场景
config = {
    'multipath_enabled': True,
    'num_rays': 720,  # 增加射线数
    'max_reflections': 4,  # 增加反射次数
    'default_material': 'concrete',
}
```

### 3. 对比分析

对比不同模式的结果：

```python
# 简化模式
config_simple = {'high_precision_mode': False}
tracer_simple = create_ray_tracer(model, config_simple)
rssi_simple = tracer_simple.simulate_signal(tx_pos, rx_pos)

# 高精度模式
config_hp = {'high_precision_mode': True, 'max_reflections': 3}
tracer_hp = create_ray_tracer(model, config_hp)
rssi_hp = tracer_hp.simulate_signal(tx_pos, rx_pos)

# 多径模式
config_mp = {'multipath_enabled': True, 'num_rays': 360}
tracer_mp = create_ray_tracer(model, config_mp)
rssi_mp = tracer_mp.simulate_signal(tx_pos, rx_pos)

print(f"简化模式: {rssi_simple:.2f} dBm")
print(f"高精度模式: {rssi_hp:.2f} dBm")
print(f"多径模式: {rssi_mp:.2f} dBm")
```

## 理论背景

### Fibonacci球面采样

多径模式使用Fibonacci球面采样算法，确保射线在球面上均匀分布：

```python
golden_ratio = (1 + √5) / 2  # 黄金比例

for i in range(num_rays):
    θ = 2π × i / golden_ratio  # 方位角
    φ = arccos(1 - 2(i + 0.5) / num_rays)  # 极角

    direction = [
        cos(θ) × sin(φ),
        sin(θ) × sin(φ),
        cos(φ)
    ]
```

这种方法比随机采样或规则网格采样更均匀。

### 功率叠加原理

电磁波的功率是**矢量叠加**（考虑相位），但在指纹定位中，我们通常假设**非相干叠加**（只考虑幅度）：

$$
P_{total} = \sum_{i=1}^{N} P_i
$$

转换为dBm：

$$
P_{total}(dBm) = 10 \log_{10}\left(\sum_{i=1}^{N} 10^{P_i(dBm)/10}\right)
$$

### 路径损耗模型

每条路径的总损耗包括：

1. **自由空间损耗**（FSPL）：
   $$FSPL(d) = 20\log_{10}(d) + 20\log_{10}(f) + 32.44$$

2. **反射损耗**：
   $$L_{refl} = -20\log_{10}(R(\theta))$$
   其中 $R(\theta)$ 是Fresnel反射系数

3. **吸收损耗**：
   $$L_{abs} = \alpha \times d$$
   其中 $\alpha$ 是材料吸收系数

总损耗：
$$L_{total} = FSPL + \sum L_{refl} + \sum L_{abs}$$

## 常见问题

### Q1: 多径模式比高精度模式慢多少？

**A**: 约10-30倍。高精度模式单点计算约2-5秒，多径模式约30-60秒。

### Q2: 什么时候应该使用多径模式？

**A**:
- ✓ 需要极高精度（<0.5m误差）
- ✓ NLOS环境严重
- ✓ 用于信道建模研究
- ✓ 时间不敏感的离线分析
- ✗ 快速原型设计
- ✗ 实时定位应用

### Q3: 多径模式会发现多少条路径？

**A**: 取决于环境复杂度：
- 空旷房间：5-20条
- 普通办公室：20-50条
- 密集环境：50-200+条

可以通过 `len(paths)` 查看实际数量。

### Q4: 如何判断多径模式是否工作正常？

**A**: 检查以下几点：

```python
paths = tracer.trace_all_paths_multipath(tx_pos, rx_pos)

# 1. 路径数量合理
assert len(paths) > 0, "没有发现任何路径！"
assert len(paths) < 1000, "路径数量异常多！"

# 2. 包含不同反射次数的路径
bounces = [p.num_bounces for p in paths]
print(f"反射次数分布: {set(bounces)}")  # 应该有0, 1, 2, 3...

# 3. 功率叠加比单路径强
single_best = min(p.total_loss for p in paths)
multipath_power = tracer.combine_multipath_power(paths)
print(f"最强单径: {config['tx_power'] - single_best:.2f} dBm")
print(f"多径叠加: {multipath_power:.2f} dBm")
# 多径叠加应该更强（dBm值更大）
```

### Q5: 能否可视化多径路径？

**A**: 可以！参考以下代码：

```python
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

fig = plt.figure(figsize=(12, 8))
ax = fig.add_subplot(111, projection='3d')

# 绘制模型
# ... (绘制墙壁等)

# 绘制多径路径
for i, path in enumerate(paths[:10]):  # 只显示前10条
    points = np.array(path.path_points)
    ax.plot(points[:, 0], points[:, 1], points[:, 2],
            label=f"{path.num_bounces}次反射",
            alpha=0.6)

# 标记TX和RX
ax.scatter(*tx_pos, c='red', s=100, marker='^', label='发射机')
ax.scatter(*rx_pos, c='blue', s=100, marker='v', label='接收机')

ax.legend()
plt.show()
```

## 总结

多径传播模式提供了最真实的室内电磁传播仿真，适合高精度定位和信道建模研究。虽然计算较慢，但结果更接近真实测量值。

**推荐使用流程**：
1. 先用简化模式快速验证（1-2分钟）
2. 再用高精度模式优化（10-30分钟）
3. 最后用多径模式达到最高精度（1-3小时）

根据实际需求平衡精度与速度！
