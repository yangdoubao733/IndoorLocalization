# å®¤å†…å®šä½ç³»ç»Ÿç®—æ³•æµç¨‹å›¾

æœ¬æ–‡æ¡£åŒ…å«å®¤å†…å®šä½ç³»ç»Ÿçš„å„ä¸ªæ ¸å¿ƒç®—æ³•æµç¨‹å›¾ï¼Œä½¿ç”¨Mermaidè¯­æ³•ç»˜åˆ¶ã€‚

---

## 1. ç³»ç»Ÿæ€»ä½“æ¶æ„æµç¨‹å›¾

```mermaid
graph TB
    Start([å¼€å§‹]) --> Mode{é€‰æ‹©æ¨¡å¼}

    %% ç¦»çº¿é˜¶æ®µ
    Mode -->|ç¦»çº¿é˜¶æ®µ| LoadModel[åŠ è½½3Dæ¨¡å‹]
    LoadModel --> UnitConvert[æ™ºèƒ½å•ä½æ£€æµ‹ä¸è½¬æ¢]
    UnitConvert --> CreateTracer[åˆ›å»ºå°„çº¿è¿½è¸ªå™¨]
    CreateTracer --> GenGrid[ç”Ÿæˆé‡‡æ ·ç½‘æ ¼]
    GenGrid --> BatchRayTrace[æ‰¹é‡å°„çº¿è¿½è¸ªä»¿çœŸ]
    BatchRayTrace --> BuildDB[æ„å»ºæŒ‡çº¹æ•°æ®åº“]
    BuildDB --> SaveDB[(ä¿å­˜æŒ‡çº¹åº“PKL)]
    SaveDB --> VisDB[å¯è§†åŒ–çƒ­å›¾]
    VisDB --> OfflineEnd([ç¦»çº¿é˜¶æ®µå®Œæˆ])

    %% åœ¨çº¿é˜¶æ®µ
    Mode -->|åœ¨çº¿é˜¶æ®µ| LoadDB[(åŠ è½½æŒ‡çº¹åº“)]
    LoadDB --> InitEngine[åˆå§‹åŒ–å®šä½å¼•æ“]
    InitEngine --> LocMode{å®šä½æ¨¡å¼}

    %% åˆä½œå®šä½
    LocMode -->|åˆä½œå®šä½| MeasureRSSI1[æµ‹é‡ä¿¡å·å¼ºåº¦RSSI]
    MeasureRSSI1 --> SelectAlgo1{é€‰æ‹©ç®—æ³•}
    SelectAlgo1 -->|KNN| KNN[Kè¿‘é‚»ç®—æ³•]
    SelectAlgo1 -->|WKNN| WKNN[åŠ æƒKè¿‘é‚»ç®—æ³•]
    SelectAlgo1 -->|æ¦‚ç‡| Prob[æ¦‚ç‡å®šä½ç®—æ³•]
    KNN --> Result1[è¿”å›ä½ç½®åæ ‡]
    WKNN --> Result1
    Prob --> Result1
    Result1 --> OnlineEnd1([å®šä½å®Œæˆ])

    %% éåˆä½œå®šä½
    LocMode -->|éåˆä½œå®šä½| ScanEM[æ‰«æç”µç£ä¿¡å·æº]
    ScanEM --> DetectDevice[æ£€æµ‹è®¾å¤‡åˆ—è¡¨]
    DetectDevice --> CollectEM[é‡‡é›†å¤šè®¾å¤‡RSSI]
    CollectEM --> TrackLoop{æŒç»­è·Ÿè¸ª?}
    TrackLoop -->|æ˜¯| SelectAlgo2[é€‰æ‹©å®šä½ç®—æ³•]
    SelectAlgo2 --> UpdatePos[æ›´æ–°è®¾å¤‡ä½ç½®]
    UpdatePos --> Sleep[ç­‰å¾…æ›´æ–°é—´éš”]
    Sleep --> CollectEM
    TrackLoop -->|å¦| OnlineEnd2([è·Ÿè¸ªç»“æŸ])

    style LoadModel fill:#e1f5ff
    style BatchRayTrace fill:#fff4e1
    style BuildDB fill:#e8f5e9
    style KNN fill:#f3e5f5
    style WKNN fill:#f3e5f5
    style Prob fill:#f3e5f5
    style ScanEM fill:#ffe0e0
```

---

## 2. 3Dæ¨¡å‹åŠ è½½ä¸å•ä½è½¬æ¢æµç¨‹

```mermaid
graph TB
    Start([åŠ è½½3Dæ¨¡å‹]) --> CheckExt{æ£€æŸ¥æ–‡ä»¶æ‰©å±•å}

    CheckExt -->|.dae| LoadDAE[ä½¿ç”¨trimeshåŠ è½½COLLADA]
    CheckExt -->|.obj| LoadOBJ[ä½¿ç”¨trimeshåŠ è½½OBJ]
    CheckExt -->|.stl| LoadSTL[ä½¿ç”¨trimeshåŠ è½½STL]

    LoadDAE --> IsScene{æ˜¯Sceneå¯¹è±¡?}
    LoadOBJ --> IsScene
    LoadSTL --> IsScene

    IsScene -->|æ˜¯| Merge[åˆå¹¶æ‰€æœ‰å‡ ä½•ä½“]
    IsScene -->|å¦| SingleMesh[å•ä¸ªç½‘æ ¼]
    Merge --> CheckUnit
    SingleMesh --> CheckUnit

    CheckUnit[æ£€æŸ¥å•ä½æ ‡ç­¾] --> UnitDetect{æ£€æµ‹åˆ°å•ä½?}

    UnitDetect -->|millimeter| SetScale1[scale = 0.001]
    UnitDetect -->|centimeter| SetScale2[scale = 0.01]
    UnitDetect -->|inch| SetScale3[scale = 0.0254]
    UnitDetect -->|meter| SetScale4[scale = 1.0]
    UnitDetect -->|æœªæ£€æµ‹åˆ°| SizeHeuristic[åŸºäºå°ºå¯¸æ¨æµ‹]

    SizeHeuristic --> CalcSize[è®¡ç®—æ¨¡å‹æœ€å¤§å°ºå¯¸]
    CalcSize --> SizeRange{å°ºå¯¸èŒƒå›´åˆ¤æ–­}

    SizeRange -->|1000-30000| InferMM[æ¨æµ‹ä¸ºæ¯«ç±³]
    SizeRange -->|100-3000| InferCM[æ¨æµ‹ä¸ºå˜ç±³]
    SizeRange -->|10-300| InferM[æ¨æµ‹ä¸ºç±³]
    SizeRange -->|å…¶ä»–| WarnUser[è­¦å‘Šç”¨æˆ·æ£€æŸ¥]

    InferMM --> SetScale1
    InferCM --> SetScale2
    InferM --> SetScale4
    WarnUser --> SetScale4

    SetScale1 --> ApplyScale{éœ€è¦ç¼©æ”¾?}
    SetScale2 --> ApplyScale
    SetScale3 --> ApplyScale
    SetScale4 --> ApplyScale

    ApplyScale -->|scale != 1| Transform[åº”ç”¨ç¼©æ”¾å˜æ¢]
    ApplyScale -->|scale == 1| NoTransform[æ— éœ€å˜æ¢]

    Transform --> CalcBounds[è®¡ç®—æ¨¡å‹è¾¹ç•Œ]
    NoTransform --> CalcBounds
    CalcBounds --> LogInfo[è®°å½•è½¬æ¢ä¿¡æ¯]
    LogInfo --> End([æ¨¡å‹åŠ è½½å®Œæˆ])

    style LoadDAE fill:#e1f5ff
    style SetScale1 fill:#fff4e1
    style Transform fill:#e8f5e9
    style LogInfo fill:#f3e5f5
```

---

## 3. å°„çº¿è¿½è¸ªç”µç£ä»¿çœŸæµç¨‹

```mermaid
graph TB
    Start([å¼€å§‹å°„çº¿è¿½è¸ª]) --> InputCheck[è¾“å…¥: APä½ç½®, æ¥æ”¶ç‚¹ä½ç½®]

    InputCheck --> CalcDist[è®¡ç®—æ¬§æ°è·ç¦»]
    CalcDist --> CalcDir[è®¡ç®—æ–¹å‘å‘é‡å¹¶å½’ä¸€åŒ–]
    CalcDir --> CreateRay[åˆ›å»ºå°„çº¿å¯¹è±¡]

    CreateRay --> RayOrigin[å°„çº¿èµ·ç‚¹ = æ¥æ”¶ç‚¹]
    RayOrigin --> RayDir[å°„çº¿æ–¹å‘ = æŒ‡å‘AP]
    RayDir --> CallTrimesh[è°ƒç”¨trimeshæ±‚äº¤]

    CallTrimesh --> TrimeshAPI[mesh.ray.intersects_location]
    TrimeshAPI --> ReturnData[è¿”å›: locations, index_ray, index_tri]

    ReturnData --> CheckHit{æœ‰äº¤ç‚¹?}

    CheckHit -->|æ— äº¤ç‚¹| NoHit[is_blocked = False]
    CheckHit -->|æœ‰äº¤ç‚¹| CalcHitDist[è®¡ç®—äº¤ç‚¹è·ç¦»]

    CalcHitDist --> CompDist{äº¤ç‚¹è·ç¦» < APè·ç¦»?}
    CompDist -->|æ˜¯| Blocked[is_blocked = True]
    CompDist -->|å¦| NotBlocked[is_blocked = False]

    NoHit --> SetRefl0[åå°„æ¬¡æ•° = 0]
    NotBlocked --> SetRefl0
    Blocked --> SetRefl1[åå°„æ¬¡æ•° = 1]

    SetRefl0 --> CalcFSPL[è®¡ç®—è‡ªç”±ç©ºé—´æŸè€—FSPL]
    SetRefl1 --> CalcFSPL

    CalcFSPL --> FSPLFormula["FSPL = 20Ã—log10(d) + 20Ã—log10(f) - 147.55"]
    FSPLFormula --> CalcReflLoss[è®¡ç®—åå°„æŸè€—]
    CalcReflLoss --> ReflLoss["åå°„æŸè€— = åå°„æ¬¡æ•° Ã— 5dB"]

    ReflLoss --> CalcRxPower[è®¡ç®—æ¥æ”¶åŠŸç‡]
    CalcRxPower --> RxFormula["Prx = Ptx - FSPL - åå°„æŸè€—"]

    RxFormula --> AddNoise[æ·»åŠ é˜´å½±è¡°è½]
    AddNoise --> Gaussian["XÏƒ ~ N(0, 4dB)"]
    Gaussian --> FinalRSSI["RSSI = Prx + XÏƒ"]

    FinalRSSI --> Return([è¿”å›RSSIå€¼])

    style CalcDist fill:#e1f5ff
    style CallTrimesh fill:#fff4e1
    style Blocked fill:#ffe0e0
    style NotBlocked fill:#e8f5e9
    style FinalRSSI fill:#f3e5f5
```

---

## 4. æ‰¹é‡å‘é‡åŒ–å°„çº¿è¿½è¸ªæµç¨‹

```mermaid
graph TB
    Start([æ‰¹é‡å°„çº¿è¿½è¸ª]) --> Input["è¾“å…¥: APæ•°ç»„(MÃ—3), æ¥æ”¶ç‚¹æ•°ç»„(NÃ—3)"]

    Input --> InitArrays[åˆå§‹åŒ–ç©ºæ•°ç»„]
    InitArrays --> Arrays["ray_origins[], ray_directions[], ray_pairs[]"]

    Arrays --> LoopRx[éå†Nä¸ªæ¥æ”¶ç‚¹]
    LoopRx --> LoopTx[éå†Mä¸ªAP]

    LoopTx --> CalcPair["è®¡ç®—: è·ç¦»ã€æ–¹å‘"]
    CalcPair --> Append["æ·»åŠ åˆ°æ•°ç»„"]
    Append --> CheckMore{æ›´å¤šAP?}

    CheckMore -->|æ˜¯| LoopTx
    CheckMore -->|å¦| CheckMoreRx{æ›´å¤šæ¥æ”¶ç‚¹?}

    CheckMoreRx -->|æ˜¯| LoopRx
    CheckMoreRx -->|å¦| Convert[è½¬æ¢ä¸ºNumPyæ•°ç»„]

    Convert --> TotalRays["æ€»å°„çº¿æ•° = N Ã— M"]
    TotalRays --> LogCount[è®°å½•å°„çº¿æ•°é‡]

    LogCount --> BatchCall[å•æ¬¡è°ƒç”¨trimesh]
    BatchCall --> BatchAPI["mesh.ray.intersects_location(å…¨éƒ¨å°„çº¿)"]

    BatchAPI --> GetResults[è·å–æ‰€æœ‰äº¤ç‚¹]
    GetResults --> InitBlocked[åˆå§‹åŒ–é®æŒ¡æ ‡è®°æ•°ç»„]
    InitBlocked --> BlockedArray["is_blocked = zeros(NÃ—M)"]

    BlockedArray --> LoopHits[éå†æ¯ä¸ªäº¤ç‚¹]
    LoopHits --> CheckHitDist[æ£€æŸ¥äº¤ç‚¹è·ç¦»]
    CheckHitDist --> MarkBlocked{äº¤ç‚¹åœ¨APä¹‹å‰?}

    MarkBlocked -->|æ˜¯| SetTrue["is_blocked[i] = True"]
    MarkBlocked -->|å¦| KeepFalse[ä¿æŒFalse]

    SetTrue --> NextHit{æ›´å¤šäº¤ç‚¹?}
    KeepFalse --> NextHit
    NextHit -->|æ˜¯| LoopHits
    NextHit -->|å¦| InitMatrix[åˆå§‹åŒ–RSSIçŸ©é˜µ]

    InitMatrix --> RSSIMatrix["rssi_matrix = zeros(N, M)"]
    RSSIMatrix --> LoopPairs[éå†æ‰€æœ‰å°„çº¿å¯¹]

    LoopPairs --> GetRefl{æ£€æŸ¥is_blocked[i]}
    GetRefl -->|True| Refl1[åå°„æ¬¡æ•° = 1]
    GetRefl -->|False| Refl0[åå°„æ¬¡æ•° = 0]

    Refl1 --> CalcRSSI[è®¡ç®—RSSI]
    Refl0 --> CalcRSSI
    CalcRSSI --> AddShadow[æ·»åŠ é˜´å½±è¡°è½]
    AddShadow --> FillMatrix["rssi_matrix[rx_idx, tx_idx] = RSSI"]

    FillMatrix --> NextPair{æ›´å¤šå°„çº¿å¯¹?}
    NextPair -->|æ˜¯| LoopPairs
    NextPair -->|å¦| Return["è¿”å›: rssi_matrix(NÃ—M)"]

    Return --> End([æ‰¹é‡è®¡ç®—å®Œæˆ])

    style Input fill:#e1f5ff
    style BatchCall fill:#fff4e1
    style InitMatrix fill:#e8f5e9
    style Return fill:#f3e5f5
    style End fill:#c8e6c9
```

---

## 5. æŒ‡çº¹åº“æ„å»ºæµç¨‹

```mermaid
graph TB
    Start([å¼€å§‹æ„å»ºæŒ‡çº¹åº“]) --> CheckModel{æ¨¡å‹å·²åŠ è½½?}

    CheckModel -->|å¦| Error1[é”™è¯¯: è¯·å…ˆåŠ è½½æ¨¡å‹]
    CheckModel -->|æ˜¯| GetConfig[è¯»å–é…ç½®å‚æ•°]

    GetConfig --> Params["ç½‘æ ¼é—´è·ã€é«˜åº¦ã€APä½ç½®ç­‰"]
    Params --> Mode{2Dæˆ–3Dæ¨¡å¼?}

    Mode -->|2D| Gen2D[ç”Ÿæˆ2Dç½‘æ ¼]
    Mode -->|3D| Gen3D[ç”Ÿæˆ3Dç½‘æ ¼]

    Gen2D --> Grid2D["XYå¹³é¢ç½‘æ ¼ + å›ºå®šé«˜åº¦Z"]
    Gen3D --> Grid3D["XYZç«‹ä½“ç½‘æ ¼ + Zå±‚é—´è·"]

    Grid2D --> CountPoints
    Grid3D --> CountPoints[è®¡ç®—é‡‡æ ·ç‚¹æ€»æ•°]

    CountPoints --> HPMode{å¯ç”¨é«˜ç²¾åº¦æ¨¡å¼?}

    HPMode -->|æ˜¯| ConfigHP[é…ç½®é«˜ç²¾åº¦å‚æ•°]
    HPMode -->|å¦| UseBasic[ä½¿ç”¨åŸºç¡€é…ç½®]

    ConfigHP --> SetReflections[è®¾ç½®æœ€å¤§åå°„æ¬¡æ•°]
    SetReflections --> SetMaterial[è®¾ç½®é»˜è®¤ææ–™]
    SetMaterial --> CheckPreset{ä½¿ç”¨åœºæ™¯é¢„è®¾?}

    CheckPreset -->|æ˜¯| LoadPreset[åŠ è½½é¢„è®¾ææ–™é…ç½®]
    CheckPreset -->|å¦| BasicMaterial[ä½¿ç”¨åŸºæœ¬ææ–™]

    LoadPreset --> CreateTracer[åˆ›å»ºé«˜ç²¾åº¦å°„çº¿è¿½è¸ªå™¨]
    BasicMaterial --> CreateTracer
    UseBasic --> CreateBasicTracer[åˆ›å»ºåŸºç¡€å°„çº¿è¿½è¸ªå™¨]

    CreateTracer --> PrepareAP
    CreateBasicTracer --> PrepareAP[å‡†å¤‡APä½ç½®æ•°ç»„]

    PrepareAP --> APArray["ap_positions = array(MÃ—3)"]
    APArray --> CalcBatch[è®¡ç®—æ‰¹æ¬¡å¤§å°]

    CalcBatch --> BatchLogic{é‡‡æ ·ç‚¹æ•°é‡}
    BatchLogic -->|â‰¤100| Batch1[batch_size = å…¨éƒ¨]
    BatchLogic -->|100-1000| Batch2[batch_size = 50]
    BatchLogic -->|1000-10000| Batch3[batch_size = 100]
    BatchLogic -->|>10000| Batch4[batch_size = 200]

    Batch1 --> InitDB[åˆå§‹åŒ–æŒ‡çº¹æ•°æ®åº“]
    Batch2 --> InitDB
    Batch3 --> InitDB
    Batch4 --> InitDB

    InitDB --> LoopBatch[éå†æ‰¹æ¬¡]
    LoopBatch --> GetBatch[è·å–å½“å‰æ‰¹æ¬¡ç‚¹]
    GetBatch --> BatchTrace[æ‰¹é‡å°„çº¿è¿½è¸ª]

    BatchTrace --> RSSIBatch["rssi_batch = simulate_signal_batch()"]
    RSSIBatch --> LoopPoints[éå†æ‰¹æ¬¡ä¸­çš„ç‚¹]

    LoopPoints --> AddFP[æ·»åŠ æŒ‡çº¹]
    AddFP --> FPData["database.add_fingerprint(pos, rssi)"]
    FPData --> UpdateProgress[æ›´æ–°è¿›åº¦æ¡]
    UpdateProgress --> Callback["progress_callback(current, total, %)"]

    Callback --> NextPoint{æ›´å¤šç‚¹?}
    NextPoint -->|æ˜¯| LoopPoints
    NextPoint -->|å¦| NextBatch{æ›´å¤šæ‰¹æ¬¡?}

    NextBatch -->|æ˜¯| LoopBatch
    NextBatch -->|å¦| SaveDB[ä¿å­˜æŒ‡çº¹åº“]

    SaveDB --> Timestamp[ç”Ÿæˆæ—¶é—´æˆ³]
    Timestamp --> SavePath["fingerprint_YYYYMMDD_HHMMSS.pkl"]
    SavePath --> Pickle[pickleåºåˆ—åŒ–]
    Pickle --> WriteFile[å†™å…¥æ–‡ä»¶]

    WriteFile --> Visualize{éœ€è¦å¯è§†åŒ–?}
    Visualize -->|æ˜¯| GenHeatmap[ç”Ÿæˆçƒ­å›¾]
    Visualize -->|å¦| End([æ„å»ºå®Œæˆ])

    GenHeatmap --> Plotly[ä½¿ç”¨Plotlyç»˜åˆ¶]
    Plotly --> SaveHTML[ä¿å­˜ä¸ºHTML]
    SaveHTML --> End

    Error1 --> End

    style CheckModel fill:#e1f5ff
    style BatchTrace fill:#fff4e1
    style SaveDB fill:#e8f5e9
    style End fill:#c8e6c9
```

---

## 6. Kè¿‘é‚»(KNN)å®šä½ç®—æ³•æµç¨‹

```mermaid
graph TB
    Start([KNNå®šä½]) --> Input["è¾“å…¥: æµ‹é‡RSSIå‘é‡(1Ã—M)"]

    Input --> CheckDB{æŒ‡çº¹åº“å·²åŠ è½½?}
    CheckDB -->|å¦| Error[é”™è¯¯: æœªåŠ è½½æŒ‡çº¹åº“]
    CheckDB -->|æ˜¯| GetRef[è·å–å‚è€ƒæŒ‡çº¹]

    GetRef --> RefData["ref_positions(NÃ—3), ref_rssi(NÃ—M)"]
    RefData --> GetK[è·å–Kå€¼]
    GetK --> AutoK{Kå€¼è®¾ç½®}

    AutoK -->|è‡ªåŠ¨| CalcK["K = min(max(8, âˆšN), 20)"]
    AutoK -->|æ‰‹åŠ¨| UserK[ä½¿ç”¨ç”¨æˆ·æŒ‡å®šK]

    CalcK --> CalcDist
    UserK --> CalcDist[è®¡ç®—æ¬§æ°è·ç¦»]

    CalcDist --> LoopRef[éå†Nä¸ªå‚è€ƒç‚¹]
    LoopRef --> Distance["d[i] = ||measured - ref_rssi[i]||â‚‚"]
    Distance --> NextRef{æ›´å¤šå‚è€ƒç‚¹?}

    NextRef -->|æ˜¯| LoopRef
    NextRef -->|å¦| Sort[æ’åºè·ç¦»]

    Sort --> Argsort["indices = argsort(distances)"]
    Argsort --> SelectK[é€‰æ‹©å‰Kä¸ª]
    SelectK --> TopK["nearest_k = indices[0:K]"]

    TopK --> GetPos[è·å–Kä¸ªä½ç½®]
    GetPos --> KPos["k_positions = ref_positions[nearest_k]"]
    KPos --> Average[è®¡ç®—å¹³å‡ä½ç½®]

    Average --> AvgX["x_est = mean(k_positions[:, 0])"]
    AvgX --> AvgY["y_est = mean(k_positions[:, 1])"]
    AvgY --> AvgZ["z_est = mean(k_positions[:, 2])"]

    AvgZ --> EstPos["estimated_position = [x_est, y_est, z_est]"]
    EstPos --> CalcConf[è®¡ç®—ç½®ä¿¡åº¦]
    CalcConf --> Confidence["confidence = 1.0 / (1.0 + avg_distance)"]

    Confidence --> Return["è¿”å›: {position, confidence}"]
    Return --> End([å®šä½å®Œæˆ])

    Error --> End

    style Input fill:#e1f5ff
    style CalcDist fill:#fff4e1
    style Average fill:#e8f5e9
    style Return fill:#f3e5f5
    style End fill:#c8e6c9
```

---

## 7. åŠ æƒKè¿‘é‚»(WKNN)å®šä½ç®—æ³•æµç¨‹

```mermaid
graph TB
    Start([WKNNå®šä½]) --> Input["è¾“å…¥: æµ‹é‡RSSIå‘é‡(1Ã—M)"]

    Input --> CheckDB{æŒ‡çº¹åº“å·²åŠ è½½?}
    CheckDB -->|å¦| Error[é”™è¯¯: æœªåŠ è½½æŒ‡çº¹åº“]
    CheckDB -->|æ˜¯| GetRef[è·å–å‚è€ƒæŒ‡çº¹]

    GetRef --> RefData["ref_positions(NÃ—3), ref_rssi(NÃ—M)"]
    RefData --> GetK[è·å–Kå€¼]
    GetK --> CalcK["K = min(max(8, âˆšN), 20)"]

    CalcK --> UseKNN[ä½¿ç”¨sklearn.NearestNeighbors]
    UseKNN --> Fit["knn_model.fit(ref_rssi)"]
    Fit --> Query["distances, indices = knn_model.kneighbors(measured, K)"]

    Query --> GetDist[è·å–Kä¸ªè·ç¦»]
    GetDist --> Distances["distances = [dâ‚, dâ‚‚, ..., dâ‚–]"]
    Distances --> AvoidZero[é¿å…é™¤é›¶]
    AvoidZero --> MaxDist["distances = max(distances, 1e-6)"]

    MaxDist --> CalcWeight[è®¡ç®—æƒé‡]
    CalcWeight --> Inverse["weights = 1.0 / distances"]
    Inverse --> Normalize[å½’ä¸€åŒ–æƒé‡]
    Normalize --> SumWeights["weights = weights / sum(weights)"]

    SumWeights --> GetPos[è·å–Kä¸ªä½ç½®]
    GetPos --> KPos["k_positions = ref_positions[indices]"]
    KPos --> Reshape["weights.reshape(-1, 1)"]

    Reshape --> Weighted[åŠ æƒå¹³å‡]
    Weighted --> WeightedSum["estimated = sum(k_positions Ã— weights, axis=0)"]
    WeightedSum --> Result["position = [x_weighted, y_weighted, z_weighted]"]

    Result --> CalcConf[è®¡ç®—ç½®ä¿¡åº¦]
    CalcConf --> AvgDist["avg_dist = mean(distances)"]
    AvgDist --> Confidence["confidence = 1.0 / (1.0 + avg_dist)"]

    Confidence --> Return["è¿”å›: {position, confidence}"]
    Return --> End([å®šä½å®Œæˆ])

    Error --> End

    style Input fill:#e1f5ff
    style CalcWeight fill:#fff4e1
    style Weighted fill:#e8f5e9
    style Return fill:#f3e5f5
    style End fill:#c8e6c9
```

---

## 8. æ¦‚ç‡å®šä½ç®—æ³•æµç¨‹

```mermaid
graph TB
    Start([æ¦‚ç‡å®šä½]) --> Input["è¾“å…¥: æµ‹é‡RSSIå‘é‡(1Ã—M)"]

    Input --> CheckDB{æŒ‡çº¹åº“å·²åŠ è½½?}
    CheckDB -->|å¦| Error[é”™è¯¯: æœªåŠ è½½æŒ‡çº¹åº“]
    CheckDB -->|æ˜¯| GetRef[è·å–å‚è€ƒæŒ‡çº¹]

    GetRef --> RefData["ref_positions(NÃ—3), ref_rssi(NÃ—M)"]
    RefData --> SetSigma[è®¾ç½®RSSIæ ‡å‡†å·®]
    SetSigma --> Sigma["Ïƒ = 4.0 dB (é»˜è®¤)"]

    Sigma --> InitProb[åˆå§‹åŒ–æ¦‚ç‡æ•°ç»„]
    InitProb --> ProbArray["probabilities = zeros(N)"]
    ProbArray --> LoopRef[éå†Nä¸ªå‚è€ƒç‚¹]

    LoopRef --> CalcDiff[è®¡ç®—RSSIå·®å€¼]
    CalcDiff --> Diff["diff = measured - ref_rssi[i]"]
    Diff --> CalcExp[è®¡ç®—æŒ‡æ•°é¡¹]
    CalcExp --> Exponent["exp = -0.5 Ã— sum((diff / Ïƒ)Â²)"]

    Exponent --> Gaussian[é«˜æ–¯æ¦‚ç‡]
    Gaussian --> Prob["probabilities[i] = exp(exponent)"]
    Prob --> NextRef{æ›´å¤šå‚è€ƒç‚¹?}

    NextRef -->|æ˜¯| LoopRef
    NextRef -->|å¦| CheckSum[æ£€æŸ¥æ¦‚ç‡å’Œ]

    CheckSum --> SumProb["sum_prob = sum(probabilities)"]
    SumProb --> IsZero{sum_prob = 0?}

    IsZero -->|æ˜¯| Fallback[å›é€€åˆ°KNN]
    IsZero -->|å¦| NormalizeProb[å½’ä¸€åŒ–æ¦‚ç‡]

    NormalizeProb --> Norm["probabilities = probabilities / sum_prob"]
    Norm --> Reshape["probabilities.reshape(-1, 1)"]
    Reshape --> WeightedAvg[æ¦‚ç‡åŠ æƒå¹³å‡]

    WeightedAvg --> WSum["estimated = sum(ref_positions Ã— probabilities, axis=0)"]
    WSum --> Result["position = [x_prob, y_prob, z_prob]"]

    Result --> CalcConf[è®¡ç®—ç½®ä¿¡åº¦]
    CalcConf --> MaxProb["max_prob = max(probabilities)"]
    MaxProb --> Confidence["confidence = max_prob"]

    Confidence --> Return["è¿”å›: {position, confidence}"]
    Fallback --> FallbackKNN[è°ƒç”¨KNNç®—æ³•]
    FallbackKNN --> Return
    Return --> End([å®šä½å®Œæˆ])

    Error --> End

    style Input fill:#e1f5ff
    style Gaussian fill:#fff4e1
    style WeightedAvg fill:#e8f5e9
    style Return fill:#f3e5f5
    style End fill:#c8e6c9
```

---

## 9. éåˆä½œå®šä½è·Ÿè¸ªæµç¨‹

```mermaid
graph TB
    Start([å¯åŠ¨éåˆä½œå®šä½]) --> InitCollector[åˆå§‹åŒ–ä¿¡å·é‡‡é›†å™¨]

    InitCollector --> Mode{é‡‡é›†å™¨æ¨¡å¼}
    Mode -->|æ¨¡æ‹Ÿ| SimCollector[UniversalEMSignalCollector]
    Mode -->|çœŸå®| RealCollector[RealEMSignalCollector]

    SimCollector --> LoadFP[åŠ è½½æŒ‡çº¹åº“]
    RealCollector --> ConnectAP[è¿æ¥çœŸå®AP]

    LoadFP --> InitTracker
    ConnectAP --> InitTracker[åˆå§‹åŒ–è®¾å¤‡è·Ÿè¸ªå™¨]

    InitTracker --> SetParams[è®¾ç½®è·Ÿè¸ªå‚æ•°]
    SetParams --> Params["update_interval, device_timeout"]
    Params --> StartLoop[å¯åŠ¨è·Ÿè¸ªå¾ªç¯]

    StartLoop --> CheckActive{tracking_active?}
    CheckActive -->|å¦| StopTrack[åœæ­¢è·Ÿè¸ª]
    CheckActive -->|æ˜¯| ScanTargets[æ‰«æä¿¡å·æº]

    ScanTargets --> Discover{è‡ªåŠ¨å‘ç°?}
    Discover -->|æ˜¯| AutoScan[è‡ªåŠ¨æ‰«æå…¨é¢‘æ®µ]
    Discover -->|å¦| ManualList[ä½¿ç”¨æ‰‹åŠ¨åˆ—è¡¨]

    AutoScan --> DeviceList
    ManualList --> DeviceList[è·å–è®¾å¤‡åˆ—è¡¨]

    DeviceList --> CheckEmpty{æœ‰è®¾å¤‡?}
    CheckEmpty -->|å¦| Sleep1[ç­‰å¾…æ›´æ–°é—´éš”]
    CheckEmpty -->|æ˜¯| LoopDevices[éå†è®¾å¤‡]

    LoopDevices --> GetDevice[è·å–è®¾å¤‡ä¿¡æ¯]
    GetDevice --> DeviceInfo["device_id, signal_type"]
    DeviceInfo --> CollectRSSI[é‡‡é›†RSSI]

    CollectRSSI --> SignalType{ä¿¡å·ç±»å‹}
    SignalType -->|WiFi| CollectWiFi[WiFi RSSI]
    SignalType -->|è“ç‰™| CollectBT[è“ç‰™ RSSI]
    SignalType -->|æ‰‹æœº| CollectCell[æ‰‹æœºä¿¡å· RSSI]
    SignalType -->|RFID| CollectRFID[RFID RSSI]
    SignalType -->|å…¶ä»–| CollectOther[å…¶ä»–ä¿¡å· RSSI]

    CollectWiFi --> RSSIVector
    CollectBT --> RSSIVector
    CollectCell --> RSSIVector
    CollectRFID --> RSSIVector
    CollectOther --> RSSIVector["rssi_vector = [rssiâ‚, rssiâ‚‚, ..., rssiâ‚˜]"]

    RSSIVector --> CheckValid{RSSIæœ‰æ•ˆ?}
    CheckValid -->|å¦| NextDevice1
    CheckValid -->|æ˜¯| Localize[è°ƒç”¨å®šä½å¼•æ“]

    Localize --> EngineCall["result = localization_engine.locate(rssi)"]
    EngineCall --> GetResult[è·å–ç»“æœ]
    GetResult --> ResultData["position, confidence"]

    ResultData --> CheckConf{confidence > é˜ˆå€¼?}
    CheckConf -->|å¦| LowConf[è®°å½•ä½ç½®ä¿¡åº¦]
    CheckConf -->|æ˜¯| UpdateDevice[æ›´æ–°è®¾å¤‡çŠ¶æ€]

    UpdateDevice --> DeviceState["devices[id].update(position, time)"]
    DeviceState --> LogPosition[è®°å½•ä½ç½®å†å²]
    LogPosition --> CheckAlarm{è§¦å‘æŠ¥è­¦?}

    CheckAlarm -->|ç¦åŒº| Alarm1[å‘é€ç¦åŒºæŠ¥è­¦]
    CheckAlarm -->|å¼‚å¸¸ç§»åŠ¨| Alarm2[å‘é€å¼‚å¸¸æŠ¥è­¦]
    CheckAlarm -->|æ­£å¸¸| NoAlarm[ç»§ç»­]

    Alarm1 --> NextDevice1
    Alarm2 --> NextDevice1
    NoAlarm --> NextDevice1
    LowConf --> NextDevice1{æ›´å¤šè®¾å¤‡?}

    NextDevice1 -->|æ˜¯| LoopDevices
    NextDevice1 -->|å¦| CleanTimeout[æ¸…ç†è¶…æ—¶è®¾å¤‡]

    CleanTimeout --> CheckTime["current_time - last_seen > timeout"]
    CheckTime --> RemoveDevice[ç§»é™¤è¶…æ—¶è®¾å¤‡]
    RemoveDevice --> Sleep2[ç­‰å¾…æ›´æ–°é—´éš”]
    Sleep1 --> CheckActive
    Sleep2 --> CheckActive

    StopTrack --> SaveLog[ä¿å­˜è·Ÿè¸ªæ—¥å¿—]
    SaveLog --> End([è·Ÿè¸ªç»“æŸ])

    style InitCollector fill:#e1f5ff
    style CollectRSSI fill:#fff4e1
    style Localize fill:#e8f5e9
    style UpdateDevice fill:#f3e5f5
    style End fill:#c8e6c9
```

---

## 10. é«˜ç²¾åº¦åå°„æ¨¡å¼æµç¨‹

```mermaid
graph TB
    Start([é«˜ç²¾åº¦åå°„æ¨¡å¼]) --> Enable{å¯ç”¨é«˜ç²¾åº¦?}

    Enable -->|å¦| BasicMode[ä½¿ç”¨ç®€åŒ–æ¨¡å¼]
    Enable -->|æ˜¯| ConfigHP[é…ç½®é«˜ç²¾åº¦å‚æ•°]

    ConfigHP --> SetMaxRefl[è®¾ç½®æœ€å¤§åå°„æ¬¡æ•°]
    SetMaxRefl --> MaxRefl["max_reflections = 2-4"]
    MaxRefl --> SetMaterial[è®¾ç½®é»˜è®¤ææ–™]
    SetMaterial --> DefMat["default_material = concrete/brick/..."]

    DefMat --> CheckPreset{ä½¿ç”¨é¢„è®¾é…ç½®?}
    CheckPreset -->|å¦| BasicConfig[åŸºæœ¬ææ–™é…ç½®]
    CheckPreset -->|æ˜¯| LoadPreset[åŠ è½½åœºæ™¯é¢„è®¾]

    LoadPreset --> PresetType{é¢„è®¾ç±»å‹}
    PresetType -->|åŠå…¬å®¤| Office["åå°„2æ¬¡, çŸ³è†æ¿"]
    PresetType -->|åœ°ä¸‹å®¤| Basement["åå°„4æ¬¡, æ··å‡åœŸ"]
    PresetType -->|ä»“åº“| Warehouse["åå°„3æ¬¡, é‡‘å±è´§æ¶"]
    PresetType -->|ä½å®…| Residential["åå°„2æ¬¡, ç –å¢™"]

    Office --> Materials
    Basement --> Materials
    Warehouse --> Materials
    Residential --> Materials
    BasicConfig --> Materials[ææ–™å±æ€§é…ç½®]

    Materials --> MatProps["reflection_coefficient, absorption_db"]
    MatProps --> CreateTracer[åˆ›å»ºé«˜ç²¾åº¦è¿½è¸ªå™¨]
    BasicMode --> CreateBasic[åˆ›å»ºåŸºç¡€è¿½è¸ªå™¨]

    CreateTracer --> TraceStart[å¼€å§‹å°„çº¿è¿½è¸ª]
    CreateBasic --> TraceStart

    TraceStart --> InitRay[åˆå§‹åŒ–å°„çº¿]
    InitRay --> RayData["origin, direction, power"]
    RayData --> BounceCount["bounce_count = 0"]
    BounceCount --> TraceLoop{bounce < max_reflections?}

    TraceLoop -->|å¦| CalcTotal[è®¡ç®—æ€»æŸè€—]
    TraceLoop -->|æ˜¯| Intersect[å°„çº¿æ±‚äº¤]

    Intersect --> TrimeshCall["locations, normals = intersect()"]
    TrimeshCall --> CheckHit{æœ‰äº¤ç‚¹?}

    CheckHit -->|å¦| CalcTotal
    CheckHit -->|æ˜¯| GetHitInfo[è·å–äº¤ç‚¹ä¿¡æ¯]

    GetHitInfo --> HitData["hit_point, hit_normal, hit_face"]
    HitData --> GetMaterial[æŸ¥è¯¢ææ–™å±æ€§]
    GetMaterial --> FaceMat["material = face_materials[hit_face]"]
    FaceMat --> GetProps[è·å–ææ–™ç³»æ•°]
    GetProps --> Props["refl_coef, absorb_db"]

    Props --> CalcReflPower[è®¡ç®—åå°„åŠŸç‡]
    CalcReflPower --> ReflPower["power *= refl_coef"]
    ReflPower --> AddAbsorb["loss += absorb_db"]
    AddAbsorb --> CalcReflDir[è®¡ç®—åå°„æ–¹å‘]

    CalcReflDir --> Fresnel["ä½¿ç”¨Fresnelå…¬å¼"]
    Fresnel --> NewDir["reflected_dir = reflect(incident, normal)"]
    NewDir --> UpdateRay[æ›´æ–°å°„çº¿]
    UpdateRay --> NewRay["origin = hit_point, direction = reflected_dir"]

    NewRay --> IncBounce["bounce_count += 1"]
    IncBounce --> CheckPower{power > threshold?}
    CheckPower -->|å¦| CalcTotal
    CheckPower -->|æ˜¯| TraceLoop

    CalcTotal --> TotalLoss["total_loss = åŸºç¡€æŸè€— + åå°„æŸè€— + å¸æ”¶æŸè€—"]
    TotalLoss --> FinalRSSI["RSSI = Ptx - total_loss"]
    FinalRSSI --> AddNoise[æ·»åŠ é˜´å½±è¡°è½]
    AddNoise --> Return[è¿”å›ç²¾ç¡®RSSI]
    Return --> End([é«˜ç²¾åº¦è¿½è¸ªå®Œæˆ])

    style ConfigHP fill:#e1f5ff
    style LoadPreset fill:#fff4e1
    style Intersect fill:#ffe0e0
    style CalcReflDir fill:#e8f5e9
    style Return fill:#f3e5f5
    style End fill:#c8e6c9
```

---

## ä½¿ç”¨è¯´æ˜

è¿™äº›æµç¨‹å›¾ä½¿ç”¨Mermaidè¯­æ³•ç¼–å†™ï¼Œå¯ä»¥åœ¨æ”¯æŒMermaidçš„MarkdownæŸ¥çœ‹å™¨ä¸­æ¸²æŸ“ï¼š

1. **GitHub**: è‡ªåŠ¨æ¸²æŸ“Mermaidå›¾è¡¨
2. **VS Code**: å®‰è£… "Markdown Preview Mermaid Support" æ’ä»¶
3. **åœ¨çº¿å·¥å…·**: https://mermaid.live/
4. **Typora**: å†…ç½®Mermaidæ”¯æŒ
5. **GitBook/Notion**: æ”¯æŒMermaidä»£ç å—

### é¢œè‰²è¯´æ˜
- ğŸ”µ æµ…è“è‰² (#e1f5ff): è¾“å…¥/åˆå§‹åŒ–æ­¥éª¤
- ğŸŸ¡ æµ…é»„è‰² (#fff4e1): æ ¸å¿ƒè®¡ç®—æ­¥éª¤
- ğŸŸ¢ æµ…ç»¿è‰² (#e8f5e9): æ•°æ®å¤„ç†/å­˜å‚¨æ­¥éª¤
- ğŸŸ£ æµ…ç´«è‰² (#f3e5f5): è¾“å‡º/ç»“æœæ­¥éª¤
- ğŸ”´ æµ…çº¢è‰² (#ffe0e0): å…³é”®å†³ç­–æ­¥éª¤
- ğŸŸ¢ æ·±ç»¿è‰² (#c8e6c9): å®ŒæˆçŠ¶æ€

---

**æ–‡æ¡£ç‰ˆæœ¬**: 1.0
**åˆ›å»ºæ—¥æœŸ**: 2025-10-15
**ä½œè€…**: Claude Code Assistant
